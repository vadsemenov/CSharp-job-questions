## Вопросы для подготовки к собеседованию по C#, платформе NET, алгоритмам и структурам данных на позицию Junior/Middle

- [Вопросы для подготовки к собеседованию по C#, платформе NET, алгоритмам и структурам данных на позицию Junior/Middle](#------------------------------------------c-------------net--------------------------------------------junior-middle)
  * [Core](#core)
  * [ООП](#ООП)
  * [Алгоритмы и структуры данных](#Алгоритмы-и-структуры-данных)
  * [Архитектура](#Архитектура)
  * [СУБД](#СУБД)
  * [Многопоточность:](#Многопоточность)

Если заметили неточности по ответу на вопрос пишите в телеграмм: [@VadSemenov](https://t.me/Vadsemenov)!

### Core

<details><summary>Вопрос 1. Что такое IL, CLR.</summary>

>IL (Intermediate Language) - это промежуточный язык, который создается компилятором .NET при компиляции исходного кода написанного на языке программирования C#, Visual Basic, F# или других языках, поддерживаемых .NET-ом. IL не является машинным кодом, он является переносимым кодом, который может быть выполнен на любой платформе, поддерживающей исполнение .NET-а.
>
>CLR (Common Language Runtime) - это среда исполнения .NET, которая контролирует управление памятью, управляет типами данных, обработкой исключений, выполнением потоков и другими аспектами, связанными с выполнением .NET-кода. CLR обеспечивает автоматическую управляемую память, что позволяет программистам работать на более высоком уровне абстракции и не заботиться о выделении и освобождении памяти.
>
>Когда .NET-приложение запускается, исполняемый файл (.exe или .dll) содержит IL-код. CLR загружает IL-код в память и компилирует его в нативный машинный код, т.е. код, который может быть выполнен процессором. Компиляция происходит JIT-компилятором, который компилирует IL-код на лету. Во время выполнения CLR контролирует работу приложения и осуществляет управление памятью. 
>
>В целом, IL и CLR являются ключевыми концепциями при разработке .NET-приложений, так как они обеспечивают переносимость и управление памятью для .NET-кода.
>
</details>

<details><summary>Вопрос 2. Что такое net Framework, net Standart, net Core и .NET. Хронология версий.</summary>

>.NET Framework – это платформа, которая предназначена для разработки и запуска приложений на языке программирования C# и других языков. Она была создана компанией Microsoft в 2002 году и предназначалась для работы в операционной системе Windows. Вышли версии начиная с 1.0 до 4.8. На данный момент новые версии не выпускаются.
>
>.NET Core – это открытая платформа, которая предназначена для разработки и запуска приложений на основе .NET. Он предназначен для работы на операционных системах Windows, Linux и macOS. Он был создан в 2014 году как более легковесная и гибкая альтернатива .NET Framework. Вышли версии с 1.0 до 3.1, далее сменила название на .NET.
>
>.NET – начиная с .NET 5, версии платформа стала называться .NET (без использования «Core» в названии), что символизирует объединение .NET Core, Mono и .NET Framework.
>
>.NET Standard – это набор API-интерфейсов, который определяет минимальные требования к реализации .NET-платформы. Он был создан в 2016 году для упрощения совместимости между различными реализациями .NET (.NET Framework и .NET Core(.NET)).
>
</details>

<details><summary>Вопрос 3. Какие в C# есть базовые типы данных их размер.
(byte, int, float и т.д.)</summary>

>В C# есть следующие базовые типы данных:

>1. Целочисленные типы:
>- sbyte (1 байт)
>- byte (1 байт)
>- short (2 байта)
>- ushort (2 байта)
>- int (4 байта)
>- uint (4 байта)
>- long (8 байт)
>- ulong (8 байт)
>
>2. Типы с плавающей точкой:
>- float (4 байта)
>- double (8 байт)
>- decimal (16 байт)
>
>3. Логический тип:
>- bool (1 байт)
>
>4. Символьные типы:
>- char (2 байта)
>
>5. Ссылочные типы:
>- object (размер зависит от типа объекта)
>- string (размер зависит от размера строки)
>
>Размеры типов данных могут варьироваться в зависимости от платформы (32- или 64-битная).
>
</details>

<details><summary>Вопрос 4. Чем ссылочные типы отличаются от значимых.</summary>

>Значимые типы (value types) хранятся в стеке памяти и оперируются напрямую, без использования указателей. Использование значимых типов экономит память, так как их значение хранится непосредственно в переменной. Таким образом, при передаче значимых типов в функцию происходит копирование их значений, что может быть ресурсоемкой операцией. Примерами значимых типов являются целые числа, логические значения, числа с плавающей точкой и т.д.
>
>Ссылочные типы (reference types) хранятся в куче памяти и оперируются через указатели на объекты. При создании переменной ссылочного типа выделяется только указатель, а на сам объект выделяется дополнительная память в куче. При передаче ссылочного типа в функцию происходит передача указателя на объект, а не его копии, что значительно экономит память. Примерами ссылочных типов являются строки, массивы, объекты классов и т.д.
>
>Также важно отметить, что ссылочные типы могут быть равны null, тогда как значимые типы всегда имеют значения по умолчанию, например, для int это 0, для bool - false и т.д.
>
</details>

<details><summary>Вопрос 5. Какие типы являются ссылочными, какие значимыми.</summary>

>Типы значений:
>
>Целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong).
>- Типы с плавающей запятой (float, double).
>- Тип decimal.
>- Тип bool
>- Тип char
>- Перечисления enum
>- Структуры (struct)
>
>Ссылочные типы:
>
>- Тип object
>- Тип string
>- Классы (class)
>- Интерфейсы (interface)
>- Делегаты (delegate)
>
</details>

<details><summary>Вопрос 6. Какой класс родительский для всех типов? Какие он имеет методы.</summary>

>Класс родительский для всех типов в C# - это класс System.Object. Он имеет следующие методы:
>
>1. Equals - сравнение двух объектов на равенство
>2. GetHashCode - возвращает хеш-код объекта
>3. GetType - возвращает объект типа System.Type, представляющий тип текущего экземпляра
>4. ToString - возвращает строковое представление текущего объекта
>
>Кроме того, класс System.Object определяет также методы, связанные с управлением жизненным циклом объекта, такие как Finalize и MemberwiseClone.
>
</details>

<details><summary>Вопрос 7. Для чего нужны методы  Equals() и GetHashCode().</summary>

>Методы Equals() и GetHashCode() в C# нужны для работы с объектами и проверки их равенства. 
>
>Метод Equals() используется для сравнения двух объектов. При этом мы можем переопределить реализацию этого метода в нашем классе, чтобы определить собственные правила сравнения. Обычно этот метод сравнивает поля объектов, определяющие их состояние.
>
>Метод GetHashCode() возвращает хеш-код текущего объекта, основанный на его уникальных свойствах, что позволяет быстро идентифицировать объект в коллекциях, использующих хеш-таблицы. Этот метод тоже может быть переопределен в классе.
>
>Если hashCode у 2 объектов равен, они не обязательно равны (Equals). Но если объекты равны, то и hashCode должен быть у них одинаков. Возможность неравенство хэшей объясняется возможной коллизией(совпадением) при вычислении хэшкода.
>
</details>

<details><summary>Вопрос 8. Как нужно переопределить Equals. Что такое Рефлексивность, 
Симметричность, Транзитивность в Equals.</summary>

>Переопределение Equals должно удовлетворять следующим условиям:
>
>- 1. Рефлексивность: любой объект должен быть равен самому себе (x.Equals(x) должен возвращать true).
>- 2. Симметричность: если объект x равен объекту y, то объект y также должен быть равен объекту x (x.Equals(y) должен возвращать true, если y.Equals(x) возвращает true).
>- 3. Транзитивность: если объект x равен объекту y, а объект y равен объекту z, то объект x должен быть равен объекту z (если x.Equals(y) возвращает true и y.Equals(z) возвращает true, то x.Equals(z) должен возвращать true).
>
>При переопределении Equals необходимо также переопределить метод GetHashCode для обеспечения совместимости с коллекциями, использующими хеширование объектов.
>Если hashCode у 2 объектов равен, они не обязательно равны (Equals). Но если объекты равны, то и hashCode должен быть у них одинаков. Возможность неравенство хэшей объясняется возможной коллизией(совпадением) при вычислении хэшкода.

>Пример переопределения:
```csharp
 public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }

    public override bool Equals(object obj)
    {
        if (obj == null || GetType() != obj.GetType())
        {
            return false;
        }
 
        if(this == obj)
        {
            return true;
        }
        
        Person other = (Person)obj;
        return Equals(Name, other.Name) && Age == other.Age; // сравниваем поля объектов
    }

    public override int GetHashCode()
    {
            int hash = 17;
            hash = hash * 23 + (Name != null ? Name.GetHashCode() : 0);
            hash = hash * 23 + Age;
            return hash;
    }
}
```
 
</details>

<details><summary>Вопрос 9. Как нужно переопределить GetHashCode.</summary>

>Когда переопределяется метод GetHashCode(), следует обратить внимание на следующие моменты:
>- 1. Возвращаемое значение метода GetHashCode() для двух эквивалентных объектов должно быть одинаковым.
>- 2. Метод GetHashCode() не должен генерировать исключения.
>
>Если hashCode у 2 объектов равен они не обязательно равны (Equals). Но если объекты равны, то и hashCode должен быть у них одинаков.
>Возможность неравенство хэшей объясняется возможной коллизией(совпадением) при вычислении хэшкода.
>
>Пример переопределения:
```csharp
 public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }

    public override bool Equals(object obj)
    {
        if (obj == null || GetType() != obj.GetType())
        {
            return false;
        }
 
        if(this == obj)
        {
            return true;
        }
        
        Person other = (Person)obj;
        return Equals(Name, other.Name) && Age == other.Age; // сравниваем поля объектов
    }

    public override int GetHashCode()
    {
            int hash = 17;
            hash = hash * 23 + (Name != null ? Name.GetHashCode() : 0);
            hash = hash * 23 + Age;
            return hash;
    }
}
```
 
</details>

<details><summary>Вопрос 10. Какие есть модификаторы доступа в C#.</summary>

>
>
</details>

<details><summary>Вопрос 11. Ключевое слово ref. Какая разница при передаче ссылочных типов в методы с 
использованием ref и без.</summary>

>
>
</details>

<details><summary>Вопрос 12. Что такое дженерики, зачем нужны. Что такое ковариантность и 
контравариантность.</summary>

>
>
</details>

<details><summary>Вопрос 13. Что такое сериализация, какие виды сериализации есть в стандартных 
сборках net.</summary>

>
>
</details>

<details><summary>Вопрос 14. Для чего нужны интерфейсы IEnumerator и IEnumerable, как реализовать в 
классе.</summary>

>
>
</details>

<details><summary>Вопрос 15. Что такое методы расширения.</summary>

>
>
</details>

<details><summary>Вопрос 16. Что такое делегаты и события.</summary>

>
>
</details>

<details><summary>Вопрос 17. Что такое лямбды, как их использовать на примере делегатов.</summary>

>
>
</details>

<details><summary>Вопрос 18. Что такое Linq, основные методы.</summary>

>
>
</details>

<details><summary>Вопрос 19. Что такое атрибуты и зачем нужны.</summary>

>
>
</details>

<details><summary>Вопрос 20. Какие основные коллекции вы применяете, в чем преимущество каждой из 
них?</summary>

>
>
</details>

<details><summary>Вопрос 21. Расскажите про using и IDisposable, как они связаны.</summary>

>
>
</details>

<details><summary>Вопрос 22. Что такое деструктор класса, как работает.</summary>

>
>
</details>

<details><summary>Вопрос 23. Как работает сборщик мусора. Что такое LOH и SOH.</summary>

>
>
</details>

<details><summary>Вопрос 24. Нарисуйте иерархию основных коллекций в C#</summary>

>
>
</details>

### ООП

<details><summary>ООП Вопрос 1. Что такое ООП. Основные принципы ООП (Инкапсуляция, наследование, 
полиморфизм, абстракция).</summary>

>
>
</details>

<details><summary>ООП Вопрос 2. Виды отношений между классами (Агрегация, Композиция, Ассоциативность).</summary>

>
>
</details>

<details><summary>ООП Вопрос 3. Расскажите и реализуйте интерфейсы IComparable и IComparator.</summary>

>
>
</details>

<details><summary>ООП Вопрос 4. Что такое переопределение и перекрытие методов, ключевое слово virtual.</summary>

>
>
</details>

<details><summary>ООП Вопрос 5. Для нужно ключевое слово sealed.</summary>

>
>
</details>

<details><summary>ООП Вопрос 6. Чем интерфейс отличается от абстрактного класса.</summary>

>
>
</details>

<details><summary>ООП Вопрос 7. Отличие статического метода от обычного.</summary>

>
>
</details>

<details><summary>ООП Вопрос 8. Что такое статический конструктор, для чего нужен.</summary>

>
>
</details>

<details><summary>ООП Вопрос 9. Расскажите принципы Solid, покажите на примере.</summary>

>
>
</details>

### Алгоритмы и структуры данных

<details><summary>Алгоритмы Вопрос 1. Что такое сложность алгоритмов О(N).</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 2. Реализовать бинарный поиск в массиве. Какая сложность алгоритма.</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 3. Что такое Stack и Queue, какая есть реализация в C#. Что значит FIFO и 
LIFO.</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 4. Реализовать одну из простых сортировок BubbleSort, InsertionSort, 
SelectionSort. Какая сложность этих алгоритмов.</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 5. Что такое односвязный список и двусвязный список. Сложность для поиска, вставки. Какая есть реализация в 
C#</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 6. Чем массив отличается списка или динамического массива, в чем недостатки.</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 7. Что такое Бинарное дерево.</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 8. Что такое самобалансирующиеся деревья AVL.</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 9. Реализовать поиск в дереве в глубину и ширину.</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 10. Что такое Хэш таблицы. Какая сложность поиска, вставки.</summary>

>
>
</details>

<details><summary>Алгоритмы Вопрос 7. Что такое множества, какие коллекции реализуют множество.</summary>

>
>
</details>

### Архитектура

<details><summary>Архитектура Вопрос 1. Какие есть основные типы паттернов (порождающие, структурные, 
поведенческие).</summary>

>
>
</details>

<details><summary>Архитектура Вопрос 2. Расскажите какие основные паттерны “Банды четырех” помните, как их 
реализовать.</summary>

>
>
</details>

<details><summary>Архитектура Вопрос 3. Расскажите про паттерн Prototype и интерфейс IClonable</summary>

>
>
</details>

<details><summary>Архитектура Вопрос 4. Расскажите как реализовать Singleton для многопоточного использования.</summary>

>
>
</details>

### СУБД

<details><summary>СУБД Вопрос 1. Что такое реляционные и нереляционные СУБД.</summary>

>
>
</details>

<details><summary>СУБД Вопрос 2. Что такое нормализация БД.</summary>

>
>
</details>

<details><summary>СУБД Вопрос 3. Что такое принципы ACID</summary>

>
>
</details>

<details><summary>СУБД Вопрос 4. Порядок выполнения операторов SQL (From- Join-Where-Group By-Having-
Select-Order by).</summary>

>
>
</details>

<details><summary>СУБД Вопрос 5. Как работает join.</summary>

>
>
</details>

<details><summary>СУБД Вопрос 6. Что такое индексы.</summary>

>
>
</details>

### Многопоточность

<details><summary>Многопоточность Вопрос 1. Как работает класс Thread и ThreadPool.</summary>

>
>
</details>

<details><summary>Многопоточность Вопрос 2. Что такое TPL.</summary>

>
>
</details>

<details><summary>Многопоточность Вопрос 3. Для чего нужен async/await, как работает.</summary>

>
>
</details>

<details><summary>Многопоточность Вопрос 4. Чем асинхронность отличается от многопоточности.</summary>

>
>
</details>

<details><summary>Многопоточность Вопрос 5. Варианты запуска Task.</summary>

>
>
</details>

<details><summary>Многопоточность Вопрос 6. Что такое процесс, домен, поток.</summary>

>
>
</details>

<details><summary>Многопоточность Вопрос 7. Какие способы синхронизации вы знаете.</summary>

>
>
</details>

<details><summary>Многопоточность Вопрос 8. Что такое DeadLock.</summary>

>
>
</details>

<details><summary>Многопоточность Вопрос 8. Что такое Race Condition.</summary>

>
>
</details>
